# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: metadata.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List

import betterproto


class WhereFrom(betterproto.Enum):
    """Where a billing field value originates from"""

    WHERE_FROM_UNSPECIFIED = 0
    NOT_PROVIDED = 1
    PDF_BILL = 2
    PDF_DETAIL_OF_BILL = 3
    CALCULATED = 4
    FIXED_VALUE = 5


class Unit(betterproto.Enum):
    """Measurement unit for field values"""

    UNIT_UNSPECIFIED = 0
    DOLLARS = 1
    KILOWATT_HOURS = 2


@dataclass
class OptionalInt32(betterproto.Message):
    """
    Wrapper for optional int32 (betterproto doesn't support proto3 optional
    keyword)
    """

    value: int = betterproto.int32_field(1)


@dataclass
class FieldSource(betterproto.Message):
    """Describes where a field value originates"""

    where_from: "WhereFrom" = betterproto.enum_field(1)
    where_on_pdf: str = betterproto.string_field(2)
    kevins_number_code: "OptionalInt32" = betterproto.message_field(3)


@dataclass
class DateFieldMetadata(betterproto.Message):
    """Metadata for date fields (no unit, just sources)"""

    where_found: List["FieldSource"] = betterproto.message_field(1)


@dataclass
class SimpleFieldMetadata(betterproto.Message):
    """Metadata for simple numeric fields (has unit + sources)"""

    unit: "Unit" = betterproto.enum_field(1)
    where_found: List["FieldSource"] = betterproto.message_field(2)


@dataclass
class TOUComponentMetadata(betterproto.Message):
    """Metadata for a single TOU component (peak/off_peak/total)"""

    unit: "Unit" = betterproto.enum_field(1)
    where_found: List["FieldSource"] = betterproto.message_field(2)


@dataclass
class TOUFieldMetadata(betterproto.Message):
    """Metadata for Time-of-Use fields (has 3 components)"""

    peak: "TOUComponentMetadata" = betterproto.message_field(1)
    off_peak: "TOUComponentMetadata" = betterproto.message_field(2)
    total: "TOUComponentMetadata" = betterproto.message_field(3)


@dataclass
class FieldMetadata(betterproto.Message):
    """Wrapper for different field metadata types (discriminated union)"""

    date_field: "DateFieldMetadata" = betterproto.message_field(1, group="metadata")
    simple_field: "SimpleFieldMetadata" = betterproto.message_field(2, group="metadata")
    tou_field: "TOUFieldMetadata" = betterproto.message_field(3, group="metadata")


@dataclass
class MeterMetadata(betterproto.Message):
    """
    Complete metadata for one meter type Uses map instead of explicit fields to
    avoid duplication with billing.proto Field names are validated at runtime
    against MeterBillingMonth
    """

    fields: Dict[str, "FieldMetadata"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class BillingStructureMetadata(betterproto.Message):
    """Complete billing structure metadata for both meter types"""

    generation_meter: "MeterMetadata" = betterproto.message_field(1)
    benefit_meter: "MeterMetadata" = betterproto.message_field(2)
