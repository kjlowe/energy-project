// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: billing.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export enum WhereFrom {
  NOT_PROVIDED = 0,
  PDF_BILL = 1,
  PDF_DETAIL_OF_BILL = 2,
  CALCULATED = 3,
  FIXED_VALUE = 4,
  UNRECOGNIZED = -1,
}

export enum NEM2AMeterType {
  NEM2A_METER_TYPE_UNSPECIFIED = 0,
  GENERATION_METER = 1,
  BENEFIT_METER = 2,
  UNRECOGNIZED = -1,
}

export interface EnergyDate {
  /** ISO 8601 date format (YYYY-MM-DD) */
  value: string;
}

export interface EnergyMetric {
  /**
   * Sometimes each metric comes from multiple values summed up.
   * This can happen when the rates change half way through the month (due to summer/winter transitions or rate hikes)
   */
  subcomponent_values: number[];
}

/** Some energy metrics are time-of-use (TOU) based, meaning they have different values for peak and off-peak times. */
export interface EnergyMetricTOU {
  peak?: EnergyMetric | undefined;
  off_peak?: EnergyMetric | undefined;
  total?: EnergyMetric | undefined;
}

/** Represents a monthly bill for a single meter within the NEM2A system. */
export interface MeterBillingMonth {
  /** The type of meter, either GenerationMeter or BenefitMeter */
  nem2a_meter_type: NEM2AMeterType;
  /** key dates */
  billing_date?: EnergyDate | undefined;
  service_end_date?:
    | EnergyDate
    | undefined;
  /** Meter values (kWh) are always mapped to time of use. */
  energy_export_meter_channel_2?: EnergyMetricTOU | undefined;
  energy_import_meter_channel_1?: EnergyMetricTOU | undefined;
  allocated_export_energy_credits?: EnergyMetricTOU | undefined;
  net_energy_usage_after_credits?:
    | EnergyMetricTOU
    | undefined;
  /** PCE values */
  pce_energy_cost?: EnergyMetricTOU | undefined;
  pce_net_generation_bonus?: EnergyMetric | undefined;
  pce_energy_commission_surcharge?: EnergyMetric | undefined;
  pce_total_energy_charges?: EnergyMetric | undefined;
  pce_nem_credit?: EnergyMetric | undefined;
  pce_generation_charges_due_cash?:
    | EnergyMetric
    | undefined;
  /** PG&E */
  pge_res_energy_charges?: EnergyMetric | undefined;
  pge_baseline_credit?: EnergyMetric | undefined;
  pge_da_cca_charges?: EnergyMetric | undefined;
  pge_total_energy_charges?: EnergyMetric | undefined;
  pge_nem_billing?: EnergyMetric | undefined;
  pge_minimum_delivery_charge?: EnergyMetric | undefined;
  pge_nem_true_up_adjustment?: EnergyMetric | undefined;
  pge_electric_delivery_charges?:
    | EnergyMetric
    | undefined;
  /** Totals */
  california_climate_credit?: EnergyMetric | undefined;
  total_bill_in_mail?: EnergyMetric | undefined;
}

export interface MonthLabel {
  /** e.g., "January" */
  month_name: string;
  /** e.g., 2024 */
  year: number;
}

/** Represents a monthly bill for a single meter within the NEM2A system. */
export interface NEM2AAggregationBillingMonth {
  year: number;
  month: number;
  /** (month_name, year) e.g., ("January", 2024) */
  month_label?: MonthLabel | undefined;
  main?: MeterBillingMonth | undefined;
  adu?: MeterBillingMonth | undefined;
}

/** Represents a billing year, which consists of multiple billing months. */
export interface BillingYear {
  start_month: number;
  start_year: number;
  num_months: number;
  /** List of tuples (month_name, year) */
  months: MonthLabel[];
  billing_months: NEM2AAggregationBillingMonth[];
}

function createBaseEnergyDate(): EnergyDate {
  return { value: "" };
}

export const EnergyDate = {
  encode(message: EnergyDate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnergyDate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnergyDate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<EnergyDate>, I>>(base?: I): EnergyDate {
    return EnergyDate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnergyDate>, I>>(object: I): EnergyDate {
    const message = createBaseEnergyDate();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEnergyMetric(): EnergyMetric {
  return { subcomponent_values: [] };
}

export const EnergyMetric = {
  encode(message: EnergyMetric, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.subcomponent_values) {
      writer.double(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnergyMetric {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnergyMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.subcomponent_values.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.subcomponent_values.push(reader.double());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<EnergyMetric>, I>>(base?: I): EnergyMetric {
    return EnergyMetric.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnergyMetric>, I>>(object: I): EnergyMetric {
    const message = createBaseEnergyMetric();
    message.subcomponent_values = object.subcomponent_values?.map((e) => e) || [];
    return message;
  },
};

function createBaseEnergyMetricTOU(): EnergyMetricTOU {
  return { peak: undefined, off_peak: undefined, total: undefined };
}

export const EnergyMetricTOU = {
  encode(message: EnergyMetricTOU, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.peak !== undefined) {
      EnergyMetric.encode(message.peak, writer.uint32(10).fork()).ldelim();
    }
    if (message.off_peak !== undefined) {
      EnergyMetric.encode(message.off_peak, writer.uint32(18).fork()).ldelim();
    }
    if (message.total !== undefined) {
      EnergyMetric.encode(message.total, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnergyMetricTOU {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnergyMetricTOU();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.peak = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.off_peak = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.total = EnergyMetric.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<EnergyMetricTOU>, I>>(base?: I): EnergyMetricTOU {
    return EnergyMetricTOU.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnergyMetricTOU>, I>>(object: I): EnergyMetricTOU {
    const message = createBaseEnergyMetricTOU();
    message.peak = (object.peak !== undefined && object.peak !== null)
      ? EnergyMetric.fromPartial(object.peak)
      : undefined;
    message.off_peak = (object.off_peak !== undefined && object.off_peak !== null)
      ? EnergyMetric.fromPartial(object.off_peak)
      : undefined;
    message.total = (object.total !== undefined && object.total !== null)
      ? EnergyMetric.fromPartial(object.total)
      : undefined;
    return message;
  },
};

function createBaseMeterBillingMonth(): MeterBillingMonth {
  return {
    nem2a_meter_type: 0,
    billing_date: undefined,
    service_end_date: undefined,
    energy_export_meter_channel_2: undefined,
    energy_import_meter_channel_1: undefined,
    allocated_export_energy_credits: undefined,
    net_energy_usage_after_credits: undefined,
    pce_energy_cost: undefined,
    pce_net_generation_bonus: undefined,
    pce_energy_commission_surcharge: undefined,
    pce_total_energy_charges: undefined,
    pce_nem_credit: undefined,
    pce_generation_charges_due_cash: undefined,
    pge_res_energy_charges: undefined,
    pge_baseline_credit: undefined,
    pge_da_cca_charges: undefined,
    pge_total_energy_charges: undefined,
    pge_nem_billing: undefined,
    pge_minimum_delivery_charge: undefined,
    pge_nem_true_up_adjustment: undefined,
    pge_electric_delivery_charges: undefined,
    california_climate_credit: undefined,
    total_bill_in_mail: undefined,
  };
}

export const MeterBillingMonth = {
  encode(message: MeterBillingMonth, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nem2a_meter_type !== 0) {
      writer.uint32(8).int32(message.nem2a_meter_type);
    }
    if (message.billing_date !== undefined) {
      EnergyDate.encode(message.billing_date, writer.uint32(18).fork()).ldelim();
    }
    if (message.service_end_date !== undefined) {
      EnergyDate.encode(message.service_end_date, writer.uint32(26).fork()).ldelim();
    }
    if (message.energy_export_meter_channel_2 !== undefined) {
      EnergyMetricTOU.encode(message.energy_export_meter_channel_2, writer.uint32(34).fork()).ldelim();
    }
    if (message.energy_import_meter_channel_1 !== undefined) {
      EnergyMetricTOU.encode(message.energy_import_meter_channel_1, writer.uint32(42).fork()).ldelim();
    }
    if (message.allocated_export_energy_credits !== undefined) {
      EnergyMetricTOU.encode(message.allocated_export_energy_credits, writer.uint32(50).fork()).ldelim();
    }
    if (message.net_energy_usage_after_credits !== undefined) {
      EnergyMetricTOU.encode(message.net_energy_usage_after_credits, writer.uint32(58).fork()).ldelim();
    }
    if (message.pce_energy_cost !== undefined) {
      EnergyMetricTOU.encode(message.pce_energy_cost, writer.uint32(66).fork()).ldelim();
    }
    if (message.pce_net_generation_bonus !== undefined) {
      EnergyMetric.encode(message.pce_net_generation_bonus, writer.uint32(74).fork()).ldelim();
    }
    if (message.pce_energy_commission_surcharge !== undefined) {
      EnergyMetric.encode(message.pce_energy_commission_surcharge, writer.uint32(82).fork()).ldelim();
    }
    if (message.pce_total_energy_charges !== undefined) {
      EnergyMetric.encode(message.pce_total_energy_charges, writer.uint32(90).fork()).ldelim();
    }
    if (message.pce_nem_credit !== undefined) {
      EnergyMetric.encode(message.pce_nem_credit, writer.uint32(98).fork()).ldelim();
    }
    if (message.pce_generation_charges_due_cash !== undefined) {
      EnergyMetric.encode(message.pce_generation_charges_due_cash, writer.uint32(106).fork()).ldelim();
    }
    if (message.pge_res_energy_charges !== undefined) {
      EnergyMetric.encode(message.pge_res_energy_charges, writer.uint32(114).fork()).ldelim();
    }
    if (message.pge_baseline_credit !== undefined) {
      EnergyMetric.encode(message.pge_baseline_credit, writer.uint32(122).fork()).ldelim();
    }
    if (message.pge_da_cca_charges !== undefined) {
      EnergyMetric.encode(message.pge_da_cca_charges, writer.uint32(130).fork()).ldelim();
    }
    if (message.pge_total_energy_charges !== undefined) {
      EnergyMetric.encode(message.pge_total_energy_charges, writer.uint32(138).fork()).ldelim();
    }
    if (message.pge_nem_billing !== undefined) {
      EnergyMetric.encode(message.pge_nem_billing, writer.uint32(146).fork()).ldelim();
    }
    if (message.pge_minimum_delivery_charge !== undefined) {
      EnergyMetric.encode(message.pge_minimum_delivery_charge, writer.uint32(154).fork()).ldelim();
    }
    if (message.pge_nem_true_up_adjustment !== undefined) {
      EnergyMetric.encode(message.pge_nem_true_up_adjustment, writer.uint32(162).fork()).ldelim();
    }
    if (message.pge_electric_delivery_charges !== undefined) {
      EnergyMetric.encode(message.pge_electric_delivery_charges, writer.uint32(170).fork()).ldelim();
    }
    if (message.california_climate_credit !== undefined) {
      EnergyMetric.encode(message.california_climate_credit, writer.uint32(178).fork()).ldelim();
    }
    if (message.total_bill_in_mail !== undefined) {
      EnergyMetric.encode(message.total_bill_in_mail, writer.uint32(186).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MeterBillingMonth {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeterBillingMonth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nem2a_meter_type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.billing_date = EnergyDate.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.service_end_date = EnergyDate.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.energy_export_meter_channel_2 = EnergyMetricTOU.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.energy_import_meter_channel_1 = EnergyMetricTOU.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.allocated_export_energy_credits = EnergyMetricTOU.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.net_energy_usage_after_credits = EnergyMetricTOU.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.pce_energy_cost = EnergyMetricTOU.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pce_net_generation_bonus = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.pce_energy_commission_surcharge = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.pce_total_energy_charges = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.pce_nem_credit = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.pce_generation_charges_due_cash = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.pge_res_energy_charges = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.pge_baseline_credit = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.pge_da_cca_charges = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.pge_total_energy_charges = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.pge_nem_billing = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.pge_minimum_delivery_charge = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.pge_nem_true_up_adjustment = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.pge_electric_delivery_charges = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.california_climate_credit = EnergyMetric.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.total_bill_in_mail = EnergyMetric.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MeterBillingMonth>, I>>(base?: I): MeterBillingMonth {
    return MeterBillingMonth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MeterBillingMonth>, I>>(object: I): MeterBillingMonth {
    const message = createBaseMeterBillingMonth();
    message.nem2a_meter_type = object.nem2a_meter_type ?? 0;
    message.billing_date = (object.billing_date !== undefined && object.billing_date !== null)
      ? EnergyDate.fromPartial(object.billing_date)
      : undefined;
    message.service_end_date = (object.service_end_date !== undefined && object.service_end_date !== null)
      ? EnergyDate.fromPartial(object.service_end_date)
      : undefined;
    message.energy_export_meter_channel_2 =
      (object.energy_export_meter_channel_2 !== undefined && object.energy_export_meter_channel_2 !== null)
        ? EnergyMetricTOU.fromPartial(object.energy_export_meter_channel_2)
        : undefined;
    message.energy_import_meter_channel_1 =
      (object.energy_import_meter_channel_1 !== undefined && object.energy_import_meter_channel_1 !== null)
        ? EnergyMetricTOU.fromPartial(object.energy_import_meter_channel_1)
        : undefined;
    message.allocated_export_energy_credits =
      (object.allocated_export_energy_credits !== undefined && object.allocated_export_energy_credits !== null)
        ? EnergyMetricTOU.fromPartial(object.allocated_export_energy_credits)
        : undefined;
    message.net_energy_usage_after_credits =
      (object.net_energy_usage_after_credits !== undefined && object.net_energy_usage_after_credits !== null)
        ? EnergyMetricTOU.fromPartial(object.net_energy_usage_after_credits)
        : undefined;
    message.pce_energy_cost = (object.pce_energy_cost !== undefined && object.pce_energy_cost !== null)
      ? EnergyMetricTOU.fromPartial(object.pce_energy_cost)
      : undefined;
    message.pce_net_generation_bonus =
      (object.pce_net_generation_bonus !== undefined && object.pce_net_generation_bonus !== null)
        ? EnergyMetric.fromPartial(object.pce_net_generation_bonus)
        : undefined;
    message.pce_energy_commission_surcharge =
      (object.pce_energy_commission_surcharge !== undefined && object.pce_energy_commission_surcharge !== null)
        ? EnergyMetric.fromPartial(object.pce_energy_commission_surcharge)
        : undefined;
    message.pce_total_energy_charges =
      (object.pce_total_energy_charges !== undefined && object.pce_total_energy_charges !== null)
        ? EnergyMetric.fromPartial(object.pce_total_energy_charges)
        : undefined;
    message.pce_nem_credit = (object.pce_nem_credit !== undefined && object.pce_nem_credit !== null)
      ? EnergyMetric.fromPartial(object.pce_nem_credit)
      : undefined;
    message.pce_generation_charges_due_cash =
      (object.pce_generation_charges_due_cash !== undefined && object.pce_generation_charges_due_cash !== null)
        ? EnergyMetric.fromPartial(object.pce_generation_charges_due_cash)
        : undefined;
    message.pge_res_energy_charges =
      (object.pge_res_energy_charges !== undefined && object.pge_res_energy_charges !== null)
        ? EnergyMetric.fromPartial(object.pge_res_energy_charges)
        : undefined;
    message.pge_baseline_credit = (object.pge_baseline_credit !== undefined && object.pge_baseline_credit !== null)
      ? EnergyMetric.fromPartial(object.pge_baseline_credit)
      : undefined;
    message.pge_da_cca_charges = (object.pge_da_cca_charges !== undefined && object.pge_da_cca_charges !== null)
      ? EnergyMetric.fromPartial(object.pge_da_cca_charges)
      : undefined;
    message.pge_total_energy_charges =
      (object.pge_total_energy_charges !== undefined && object.pge_total_energy_charges !== null)
        ? EnergyMetric.fromPartial(object.pge_total_energy_charges)
        : undefined;
    message.pge_nem_billing = (object.pge_nem_billing !== undefined && object.pge_nem_billing !== null)
      ? EnergyMetric.fromPartial(object.pge_nem_billing)
      : undefined;
    message.pge_minimum_delivery_charge =
      (object.pge_minimum_delivery_charge !== undefined && object.pge_minimum_delivery_charge !== null)
        ? EnergyMetric.fromPartial(object.pge_minimum_delivery_charge)
        : undefined;
    message.pge_nem_true_up_adjustment =
      (object.pge_nem_true_up_adjustment !== undefined && object.pge_nem_true_up_adjustment !== null)
        ? EnergyMetric.fromPartial(object.pge_nem_true_up_adjustment)
        : undefined;
    message.pge_electric_delivery_charges =
      (object.pge_electric_delivery_charges !== undefined && object.pge_electric_delivery_charges !== null)
        ? EnergyMetric.fromPartial(object.pge_electric_delivery_charges)
        : undefined;
    message.california_climate_credit =
      (object.california_climate_credit !== undefined && object.california_climate_credit !== null)
        ? EnergyMetric.fromPartial(object.california_climate_credit)
        : undefined;
    message.total_bill_in_mail = (object.total_bill_in_mail !== undefined && object.total_bill_in_mail !== null)
      ? EnergyMetric.fromPartial(object.total_bill_in_mail)
      : undefined;
    return message;
  },
};

function createBaseMonthLabel(): MonthLabel {
  return { month_name: "", year: 0 };
}

export const MonthLabel = {
  encode(message: MonthLabel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.month_name !== "") {
      writer.uint32(10).string(message.month_name);
    }
    if (message.year !== 0) {
      writer.uint32(16).int32(message.year);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MonthLabel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonthLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.month_name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.year = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MonthLabel>, I>>(base?: I): MonthLabel {
    return MonthLabel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MonthLabel>, I>>(object: I): MonthLabel {
    const message = createBaseMonthLabel();
    message.month_name = object.month_name ?? "";
    message.year = object.year ?? 0;
    return message;
  },
};

function createBaseNEM2AAggregationBillingMonth(): NEM2AAggregationBillingMonth {
  return { year: 0, month: 0, month_label: undefined, main: undefined, adu: undefined };
}

export const NEM2AAggregationBillingMonth = {
  encode(message: NEM2AAggregationBillingMonth, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.year !== 0) {
      writer.uint32(8).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(16).int32(message.month);
    }
    if (message.month_label !== undefined) {
      MonthLabel.encode(message.month_label, writer.uint32(26).fork()).ldelim();
    }
    if (message.main !== undefined) {
      MeterBillingMonth.encode(message.main, writer.uint32(34).fork()).ldelim();
    }
    if (message.adu !== undefined) {
      MeterBillingMonth.encode(message.adu, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NEM2AAggregationBillingMonth {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNEM2AAggregationBillingMonth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.year = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.month = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.month_label = MonthLabel.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.main = MeterBillingMonth.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.adu = MeterBillingMonth.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<NEM2AAggregationBillingMonth>, I>>(base?: I): NEM2AAggregationBillingMonth {
    return NEM2AAggregationBillingMonth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NEM2AAggregationBillingMonth>, I>>(object: I): NEM2AAggregationBillingMonth {
    const message = createBaseNEM2AAggregationBillingMonth();
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    message.month_label = (object.month_label !== undefined && object.month_label !== null)
      ? MonthLabel.fromPartial(object.month_label)
      : undefined;
    message.main = (object.main !== undefined && object.main !== null)
      ? MeterBillingMonth.fromPartial(object.main)
      : undefined;
    message.adu = (object.adu !== undefined && object.adu !== null)
      ? MeterBillingMonth.fromPartial(object.adu)
      : undefined;
    return message;
  },
};

function createBaseBillingYear(): BillingYear {
  return { start_month: 0, start_year: 0, num_months: 0, months: [], billing_months: [] };
}

export const BillingYear = {
  encode(message: BillingYear, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.start_month !== 0) {
      writer.uint32(8).int32(message.start_month);
    }
    if (message.start_year !== 0) {
      writer.uint32(16).int32(message.start_year);
    }
    if (message.num_months !== 0) {
      writer.uint32(24).int32(message.num_months);
    }
    for (const v of message.months) {
      MonthLabel.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.billing_months) {
      NEM2AAggregationBillingMonth.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BillingYear {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBillingYear();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start_month = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.start_year = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.num_months = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.months.push(MonthLabel.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.billing_months.push(NEM2AAggregationBillingMonth.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BillingYear>, I>>(base?: I): BillingYear {
    return BillingYear.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BillingYear>, I>>(object: I): BillingYear {
    const message = createBaseBillingYear();
    message.start_month = object.start_month ?? 0;
    message.start_year = object.start_year ?? 0;
    message.num_months = object.num_months ?? 0;
    message.months = object.months?.map((e) => MonthLabel.fromPartial(e)) || [];
    message.billing_months = object.billing_months?.map((e) => NEM2AAggregationBillingMonth.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };
