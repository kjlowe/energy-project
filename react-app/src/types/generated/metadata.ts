// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: metadata.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

/** Where a billing field value originates from */
export enum WhereFrom {
  WHERE_FROM_UNSPECIFIED = 0,
  /** NOT_PROVIDED - Data not provided for this meter type */
  NOT_PROVIDED = 1,
  /** PDF_BILL - Found on main PDF bill */
  PDF_BILL = 2,
  /** PDF_DETAIL_OF_BILL - Found on detailed bill section */
  PDF_DETAIL_OF_BILL = 3,
  /** CALCULATED - Derived/calculated from other fields */
  CALCULATED = 4,
  /** FIXED_VALUE - Constant value */
  FIXED_VALUE = 5,
  UNRECOGNIZED = -1,
}

/** Measurement unit for field values */
export enum Unit {
  UNIT_UNSPECIFIED = 0,
  /** DOLLARS - $ */
  DOLLARS = 1,
  /** KILOWATT_HOURS - kWh */
  KILOWATT_HOURS = 2,
  UNRECOGNIZED = -1,
}

/** Wrapper for optional int32 (betterproto doesn't support proto3 optional keyword) */
export interface OptionalInt32 {
  value: number;
}

/** Describes where a field value originates */
export interface FieldSource {
  /** Source type */
  where_from: WhereFrom;
  /** PDF location (e.g., "Page 3", "Header") */
  where_on_pdf: string;
  /** Legacy reference code (null message = not set) */
  kevins_number_code?: OptionalInt32 | undefined;
}

/** Metadata for date fields (no unit, just sources) */
export interface DateFieldMetadata {
  /** Can have multiple sources */
  where_found: FieldSource[];
}

/** Metadata for simple numeric fields (has unit + sources) */
export interface SimpleFieldMetadata {
  /** kWh or $ */
  unit: Unit;
  where_found: FieldSource[];
}

/** Metadata for a single TOU component (peak/off_peak/total) */
export interface TOUComponentMetadata {
  unit: Unit;
  where_found: FieldSource[];
}

/** Metadata for Time-of-Use fields (has 3 components) */
export interface TOUFieldMetadata {
  peak?: TOUComponentMetadata | undefined;
  off_peak?: TOUComponentMetadata | undefined;
  total?: TOUComponentMetadata | undefined;
}

/** Wrapper for different field metadata types (discriminated union) */
export interface FieldMetadata {
  metadata?:
    | { $case: "date_field"; date_field: DateFieldMetadata }
    | { $case: "simple_field"; simple_field: SimpleFieldMetadata }
    | { $case: "tou_field"; tou_field: TOUFieldMetadata }
    | undefined;
}

/**
 * Complete metadata for one meter type
 * Uses map instead of explicit fields to avoid duplication with billing.proto
 * Field names are validated at runtime against MeterBillingMonth
 */
export interface MeterMetadata {
  fields: { [key: string]: FieldMetadata };
}

export interface MeterMetadata_FieldsEntry {
  key: string;
  value?: FieldMetadata | undefined;
}

/** Complete billing structure metadata for both meter types */
export interface BillingStructureMetadata {
  generation_meter?: MeterMetadata | undefined;
  benefit_meter?: MeterMetadata | undefined;
}

function createBaseOptionalInt32(): OptionalInt32 {
  return { value: 0 };
}

export const OptionalInt32 = {
  encode(message: OptionalInt32, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OptionalInt32 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionalInt32();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<OptionalInt32>, I>>(base?: I): OptionalInt32 {
    return OptionalInt32.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OptionalInt32>, I>>(object: I): OptionalInt32 {
    const message = createBaseOptionalInt32();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseFieldSource(): FieldSource {
  return { where_from: 0, where_on_pdf: "", kevins_number_code: undefined };
}

export const FieldSource = {
  encode(message: FieldSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.where_from !== 0) {
      writer.uint32(8).int32(message.where_from);
    }
    if (message.where_on_pdf !== "") {
      writer.uint32(18).string(message.where_on_pdf);
    }
    if (message.kevins_number_code !== undefined) {
      OptionalInt32.encode(message.kevins_number_code, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FieldSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.where_from = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.where_on_pdf = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.kevins_number_code = OptionalInt32.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<FieldSource>, I>>(base?: I): FieldSource {
    return FieldSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldSource>, I>>(object: I): FieldSource {
    const message = createBaseFieldSource();
    message.where_from = object.where_from ?? 0;
    message.where_on_pdf = object.where_on_pdf ?? "";
    message.kevins_number_code = (object.kevins_number_code !== undefined && object.kevins_number_code !== null)
      ? OptionalInt32.fromPartial(object.kevins_number_code)
      : undefined;
    return message;
  },
};

function createBaseDateFieldMetadata(): DateFieldMetadata {
  return { where_found: [] };
}

export const DateFieldMetadata = {
  encode(message: DateFieldMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.where_found) {
      FieldSource.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DateFieldMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateFieldMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.where_found.push(FieldSource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<DateFieldMetadata>, I>>(base?: I): DateFieldMetadata {
    return DateFieldMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DateFieldMetadata>, I>>(object: I): DateFieldMetadata {
    const message = createBaseDateFieldMetadata();
    message.where_found = object.where_found?.map((e) => FieldSource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSimpleFieldMetadata(): SimpleFieldMetadata {
  return { unit: 0, where_found: [] };
}

export const SimpleFieldMetadata = {
  encode(message: SimpleFieldMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.unit !== 0) {
      writer.uint32(8).int32(message.unit);
    }
    for (const v of message.where_found) {
      FieldSource.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SimpleFieldMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleFieldMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.unit = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.where_found.push(FieldSource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<SimpleFieldMetadata>, I>>(base?: I): SimpleFieldMetadata {
    return SimpleFieldMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleFieldMetadata>, I>>(object: I): SimpleFieldMetadata {
    const message = createBaseSimpleFieldMetadata();
    message.unit = object.unit ?? 0;
    message.where_found = object.where_found?.map((e) => FieldSource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTOUComponentMetadata(): TOUComponentMetadata {
  return { unit: 0, where_found: [] };
}

export const TOUComponentMetadata = {
  encode(message: TOUComponentMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.unit !== 0) {
      writer.uint32(8).int32(message.unit);
    }
    for (const v of message.where_found) {
      FieldSource.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TOUComponentMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTOUComponentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.unit = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.where_found.push(FieldSource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<TOUComponentMetadata>, I>>(base?: I): TOUComponentMetadata {
    return TOUComponentMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TOUComponentMetadata>, I>>(object: I): TOUComponentMetadata {
    const message = createBaseTOUComponentMetadata();
    message.unit = object.unit ?? 0;
    message.where_found = object.where_found?.map((e) => FieldSource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTOUFieldMetadata(): TOUFieldMetadata {
  return { peak: undefined, off_peak: undefined, total: undefined };
}

export const TOUFieldMetadata = {
  encode(message: TOUFieldMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.peak !== undefined) {
      TOUComponentMetadata.encode(message.peak, writer.uint32(10).fork()).ldelim();
    }
    if (message.off_peak !== undefined) {
      TOUComponentMetadata.encode(message.off_peak, writer.uint32(18).fork()).ldelim();
    }
    if (message.total !== undefined) {
      TOUComponentMetadata.encode(message.total, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TOUFieldMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTOUFieldMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.peak = TOUComponentMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.off_peak = TOUComponentMetadata.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.total = TOUComponentMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<TOUFieldMetadata>, I>>(base?: I): TOUFieldMetadata {
    return TOUFieldMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TOUFieldMetadata>, I>>(object: I): TOUFieldMetadata {
    const message = createBaseTOUFieldMetadata();
    message.peak = (object.peak !== undefined && object.peak !== null)
      ? TOUComponentMetadata.fromPartial(object.peak)
      : undefined;
    message.off_peak = (object.off_peak !== undefined && object.off_peak !== null)
      ? TOUComponentMetadata.fromPartial(object.off_peak)
      : undefined;
    message.total = (object.total !== undefined && object.total !== null)
      ? TOUComponentMetadata.fromPartial(object.total)
      : undefined;
    return message;
  },
};

function createBaseFieldMetadata(): FieldMetadata {
  return { metadata: undefined };
}

export const FieldMetadata = {
  encode(message: FieldMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.metadata?.$case) {
      case "date_field":
        DateFieldMetadata.encode(message.metadata.date_field, writer.uint32(10).fork()).ldelim();
        break;
      case "simple_field":
        SimpleFieldMetadata.encode(message.metadata.simple_field, writer.uint32(18).fork()).ldelim();
        break;
      case "tou_field":
        TOUFieldMetadata.encode(message.metadata.tou_field, writer.uint32(26).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FieldMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = { $case: "date_field", date_field: DateFieldMetadata.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metadata = {
            $case: "simple_field",
            simple_field: SimpleFieldMetadata.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = { $case: "tou_field", tou_field: TOUFieldMetadata.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<FieldMetadata>, I>>(base?: I): FieldMetadata {
    return FieldMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldMetadata>, I>>(object: I): FieldMetadata {
    const message = createBaseFieldMetadata();
    if (
      object.metadata?.$case === "date_field" &&
      object.metadata?.date_field !== undefined &&
      object.metadata?.date_field !== null
    ) {
      message.metadata = { $case: "date_field", date_field: DateFieldMetadata.fromPartial(object.metadata.date_field) };
    }
    if (
      object.metadata?.$case === "simple_field" &&
      object.metadata?.simple_field !== undefined &&
      object.metadata?.simple_field !== null
    ) {
      message.metadata = {
        $case: "simple_field",
        simple_field: SimpleFieldMetadata.fromPartial(object.metadata.simple_field),
      };
    }
    if (
      object.metadata?.$case === "tou_field" &&
      object.metadata?.tou_field !== undefined &&
      object.metadata?.tou_field !== null
    ) {
      message.metadata = { $case: "tou_field", tou_field: TOUFieldMetadata.fromPartial(object.metadata.tou_field) };
    }
    return message;
  },
};

function createBaseMeterMetadata(): MeterMetadata {
  return { fields: {} };
}

export const MeterMetadata = {
  encode(message: MeterMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.fields).forEach(([key, value]) => {
      MeterMetadata_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MeterMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeterMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MeterMetadata_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MeterMetadata>, I>>(base?: I): MeterMetadata {
    return MeterMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MeterMetadata>, I>>(object: I): MeterMetadata {
    const message = createBaseMeterMetadata();
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: FieldMetadata }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = FieldMetadata.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMeterMetadata_FieldsEntry(): MeterMetadata_FieldsEntry {
  return { key: "", value: undefined };
}

export const MeterMetadata_FieldsEntry = {
  encode(message: MeterMetadata_FieldsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      FieldMetadata.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MeterMetadata_FieldsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeterMetadata_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = FieldMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MeterMetadata_FieldsEntry>, I>>(base?: I): MeterMetadata_FieldsEntry {
    return MeterMetadata_FieldsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MeterMetadata_FieldsEntry>, I>>(object: I): MeterMetadata_FieldsEntry {
    const message = createBaseMeterMetadata_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? FieldMetadata.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBillingStructureMetadata(): BillingStructureMetadata {
  return { generation_meter: undefined, benefit_meter: undefined };
}

export const BillingStructureMetadata = {
  encode(message: BillingStructureMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.generation_meter !== undefined) {
      MeterMetadata.encode(message.generation_meter, writer.uint32(10).fork()).ldelim();
    }
    if (message.benefit_meter !== undefined) {
      MeterMetadata.encode(message.benefit_meter, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BillingStructureMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBillingStructureMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.generation_meter = MeterMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.benefit_meter = MeterMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BillingStructureMetadata>, I>>(base?: I): BillingStructureMetadata {
    return BillingStructureMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BillingStructureMetadata>, I>>(object: I): BillingStructureMetadata {
    const message = createBaseBillingStructureMetadata();
    message.generation_meter = (object.generation_meter !== undefined && object.generation_meter !== null)
      ? MeterMetadata.fromPartial(object.generation_meter)
      : undefined;
    message.benefit_meter = (object.benefit_meter !== undefined && object.benefit_meter !== null)
      ? MeterMetadata.fromPartial(object.benefit_meter)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };
